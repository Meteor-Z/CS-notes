# TCP_IP

所有代码基本上都是在`Arch Linux`上运行，并且使用的版本是`gcc 13.1`最新版本。
现在主要是在wsl中进行开发

`linux`平台上和`windows`平台上，没有进行统一,`std::net`在`C++26` 或者`C++29` 才会加入到标准库里面，我哭死。

文件句柄/描述符：是为了称呼操作系统所创建的文件或者套接字罢了。

不过`c++` 在文件上还会做到了统一，不需要进行底层处理。

## 套接字类型和协议设置

基本现在还是IPV4

## 地址与数据序列

不是很懂网络地址分类，这个A类，B类，C类，

端口号区别应用程序，一般是`0~65536`,`0~1023`是分配到知名应用端口，有特定的用处，`TCP`和`UDP`可以公用一个端口号。

`struct sockaddr_in`就是保存这些信息的，（IP地址+端口号）

### 网络字节序与地址变换

在`csapp`上可以知道，对于一个32位的整数来说，一个数字1 可以有两种表示方法，大端法和小端法。
咱们用的就是大端法。 网络序列-> 大端序

```in
00000000 00000000 00000000 00000001
00000001 00000000 00000000 00000000
```

同时，对于TCP/IP来说，TCP是没有数据边界的，就是发送的时候是发送了三个，但是接收的时候有可能一次就接收到了，这就是粘包问题

会发生转化，在一些机子上不会发生改变

## 服务端/客户端 请求顺序

1. TCP客户端 : socket() -> connect() -> read()/write() -> close()
2. TCP服务端 : socket() -> bind() -> listen() -> accept() -> read()/write() -> close()

具体图片是这样的
![服务端和客户端之间进行交互](https://x.imgs.ovh/x/2023/09/06/64f85640d4b9d.png)

TCP是没有数据边界的，但是UDP是有数据边界的，需要接几次就要收几次.

## TCP的三次握手

SEQ:发送的信息号，对面想要什么，我可以发什么
ACK:希望对方能给我什么的数据号的下一位，

```text
A->B:
[SYN] SEQ: 1000, ACK: -
现在的数据包是1000， 如果接收无误，请通知我传递1001数据包
B->A:
[SYN+ACK]: SEQ:2000 ACk:1001
现在传递的数据包序号是2000，如果接收无误，请向我传递2001号数据包，刚才接收的SEQ为1000的数据包无误，请向我传递SEQ为1001的数据包
[A->B]:
[ACK]:SEQ:1001, ACK:2001
已经接收到SEQ为2000的数据包了，现在可以传输为2001的数据包了
```

但是具体的ACK号 SEQ + 传递的字节数 + 1, 因为要确保每次传输的数据都正确 ， + 1 是为了告对方要传递的SEQ号。

如果没有传递够，那么会等待计时器会传送ACK让他应答，如果计时器发生超市，则需要重传。

## 套接字的四次挥手

```text
[A]:我希望断开连接
[B]:哦是么，请稍等
[B]:我可以了，请断开连接
[A]:好的，谢谢
```

流量控制是UDP和TCP的重要区别，为什么TCP比UDP慢呢？

1. 收发数据前后进行的连接设置以及清楚过程
2. 收发数据过程中为保证可靠性而添加的流控制（比如说缓存那个

对于已经连接上的UDP，可以采用已连接形式的数据报发送给服务端。
![缺点](https://x.imgs.ovh/x/2023/09/11/64febe2d14026.png)

可以调用connect进行对已连接的服务器进行连接。

## 半关闭流

很多流如果全部关闭的话，那么所有的信息都会失踪，所以要半关闭流。

## 遇到的问题

- 如果缓冲区容量比较小，如果接收到一个比较大的流量怎么办？
  - TCP会控制数据流，有滑动窗口（学）。

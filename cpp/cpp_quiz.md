# cpp quiz

## 1

```c++
#include <iostream>

template <class T> void f(T &i) { std::cout << 1; }

template <> void f(const int &i) { std::cout << 2; }

int main() {
  int i = 42;
  f(i);
}
```

答案: 输出 1
这里进行了模板特化，但是函数匹配的时候更倾向于匹配更接近的，所以这里是选择的是`T&`。所以模板被实例化了 f<int>(1);

## 2

## 3

```c++
#include <iostream>

void f(int) { std::cout << 1; }
void f(unsigned) { std::cout << 2; }

int main() {
  f(-2.5);
}
```

答案 报错
double是不可以直接转换成int和unsigned的，需要强制类型转换，`浮点数无法自动转换为整数或无符号整数类型`

## 4

## 5

## 6

## 7

## 8

## 9

## 10

## 11

## 12

## 13

## 14

## 15

## 16

## 17

## 18

## 19

## 20

## 21

## 22

## 23

## 24

## 25

## 26

## 27

## 28

## 29

## 30

```c++
#include <iostream>
struct X {
  X() { std::cout << "X"; }
};

int main() { X x(); }
```

答案 无输出
`当一个东西能被看作一个声明或者一个定义的时候，优先看作成一个声明，所以这里`, 这里`X X();`的实际意义是声明一个函数，这个函数会返回类型为X的结构体。

## 31

## 32

```c++
#include <iostream>

struct X {
  X() { std::cout << "a"; }
  X(const X &x) { std::cout << "b"; }
  const X &operator=(const X &x) {
    std::cout << "c";
    return *this;
  }
};

int main() {
  X x; // 1
  X y(x); // 2
  X z = y; // 3
  z = x; // 4
}
```

答案： 输出 abbc
很简单，了解初始化和赋值就知道了。1 2 3 都是初始化，但是 1 是无参初始化,2 3 长得不一样，但是调用的都是`X (const X& x)`,4是赋值，调用的是 `operator =`.

## 33

## 34

## 35

## 36

## 37

## 38

## 39

## 40

## 41

## 42

## 43

## 44

## 45

## 46

## 47

## 48

## 49

```c++
#include <iostream>

class C {
public:
  C(int i) : i(i) { std::cout << i; }
  ~C() { std::cout << i + 5; }

private:
  int i;
};

int main() {
  const C &c = C(1);
  C(2);
  C(3);
}
```

输出 127386
`C(2) C(3)` 是匿名对象，他的生命周期只在当前行有效，生成之后，立即就消失了，但是这里`const C& `延长了生命周期，等到`}`只有，才会进行析构，这里当然可以用`&&`来进行引用。当然不可以是`&`。

## 50

## 51

## 52

## 53

## 54

## 55

## 56

## 57

## 58

## 59

## 60

## 61

## 62

## 63

## 64

## 65

## 66

## 67

## 68

## 69

## 70

## 71

## 72

## 73

## 74

## 75

## 76

## 77

## 78

## 79

## 80

## 81

## 82

## 83

## 84

## 85

## 86

## 87

## 88

## 89

## 90

## 91

## 92

## 93

## 94

## 95

## 96

## 97

## 98

## 99

## 100

## 101

## 102

## 103

## 104

## 105

## 106

## 107

## 108

## 109

## 110

## 111

## 112

## 113

## 114

## 115

## 116

## 117

## 118

## 119

## 120

## 121

## 122

## 123

## 124

## 125

## 126

## 127

## 128

## 129

## 130

## 131

## 132

## 133

## 134

## 135

## 136

## 137

## 138

## 139

## 140

## 141

## 142

## 143

## 144

## 145

## 146

## 147

## 148

## 149

## 150

## 151

## 152

## 153

## 154

## 155

## 156

## 157

## 158

## 159

## 160

## 161

## 162

## 163

## 164

## 165

## 166

## 167

## 168

## 169

## 170

## 171

## 172

## 173

## 174

## 175

## 176

## 177

## 178

## 179

## 180

## 181

## 182

## 183

## 184

## 185

## 186

## 187

## 188

## 189

## 190

## 191

## 192

## 193

## 194

## 195

## 196

## 197

## 198

## 199

## 200

## 201

## 202

## 203

## 204

## 205

## 206

## 207

## 208

## 209

## 210

## 211

## 212

## 213

## 214

## 215

## 216

## 217

## 218

## 219

## 220

## 221

## 222

## 223

## 224

## 225

## 226

## 227

## 228

## 229

## 230

## 231

## 232

## 233

## 234

## 235

## 236

## 237

## 238

## 239

## 240

## 241

## 242

## 243

## 244

## 245

## 246

## 247

## 248

## 249

## 250

## 251

## 252

## 253

## 254

## 255

## 256

## 257

## 258

## 259

## 260

## 261

## 262

## 263

## 264

## 265

## 266

## 267

## 268

## 269

## 270

## 271

## 272

## 273

## 274

## 275

## 276

## 277

## 278

## 279

## 280

## 281

## 295

```c++
#include <iostream>

char a[2] = "0";

struct a_string {
   a_string() { *a='1'; }
   ~a_string() { *a='0'; }
   const char* c_str() const { return a; }
};

void print(const char* s) { std::cout << s; }
a_string make_string() { return a_string{}; } // one

int main() {   
   a_string s1 = make_string();
   print(s1.c_str());

   const char* s2 = make_string().c_str();
   print(s2);

   print(make_string().c_str());
}
```

答案: 输出 101
注意one的时候是返回一个临时对象，这里如果没有延长生命周期的话，那么就会直接被销毁，然后就会将这个字符串常量值更改。

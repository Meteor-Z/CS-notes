# 深入探索C++对象模型

`c++`具有零成本抽象能力，对于对象封装，如`struct`和`class`等的封装，并不会增加其布局成本，`任何空间或者执行期的影响`，对于`namespace`,`class`,`struct`本质上就是限制了其作用范围，但是增加其布局成本和存取时间主要由虚函数所造成的。

注意：当封装成类的时候，会有内存对齐，但是这里是与系统结构有关，所以这里还是零成本抽象。

零成本抽象：`不用的东西，你不需要为之付出代价；再进一步说，用到的东西，你也不可能做得更好。`

1. 虚函数（virtual function）机制：支持有效率的执行期绑定
2. 虚类（virtual base class）t（实现多次出现在继承体系中的基类，不是很懂。

## C++ 对象模型

c++对象模型差不多是这样的：

1. 非静态成员变量是放在每一个对象中的，而静态的成员变量则是存放在`个别`的对象中。静态的成员函数和非静态成员函数放在`个别`的对象中，
2. 每一个类产生一堆指向虚函数的指针，放在表格中，表格称之为`virtual table (vtbl)`,然后，每一个对象都会有一个指针指向相对应的虚表（virtual table）,这个指针叫做vptr,每一个类所关联的`type_info`对象（用于支持RTTI）,会放在虚表中的第一个。

请注意，析构函数本身就是一个虚函数，会放在虚表中。

请注意：根据上面的，本质上类中其实只有非静态成员的，因为类中的函数其实就是一个作用域限制的问题，所以说`sizeof()`之后会算出他实际占用的大小，但是如果有虚函数，那么这个对象中就会有一个`虚指针`跟上面的一样，会占用一个8字节的大小的东西。

## 对象

程序模型，抽象数据类型模型，面向对象模型，

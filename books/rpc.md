# rpc

## 设置一个好的rpc协议

因为tcp协议只是将内容从A传递到B,并没有规定数据边界，需要自己实现一个协议，表示协议长度，所以要有协议长度和协议体，并且为了以后的可扩展性，需要设置一个可扩展的协议体。
所以要有一定的可变长度，否则超出数据边界的话，就会发生错误。

## 传输

传输的时候，要考虑这几个方面

- 安全
- 通用性
- 兼容性：肯定要向后兼容
- 性能
- 效率
- 空间开销：网络传输需要消耗一定的网络资源

### 序列化和反序列化

A端通过网络调用B端口的参数，需要将调用参数进行数据化成二进制数据（网络中传输的就是二进制数据），然后将数据发送到B端之后，再反序列化成参数数据就可以直接调用了。

序列化的时候要将对象数据库中，要加入一些特殊的间隔符，用于将反序列化过程中截断用，

#### 用什么序列化

- json：开销比较大，需要比较大的内存和磁盘开销。并且相当于一个个的字符串（kv存储，而且不是强类型
- hessian: 没听说过，
- protobuf:以后要用的

### 传输注意事项

1. 对象简单，没有太多依赖，属性不要过多，高内聚，低耦合
2. 入参对象与返回值对象不要过大，不要传入过大的集合
3. 尽量使用简单，常用，原生对象
4. 必要有复杂的继承关系。

## 网络模型

肯定要优先使用非堵塞的模型,

多个网络接口IO注册到同一个复用器上，当用户调用了相关select,那么整个进程都会堵塞，内核会监视所有select负责的socket,其中一个数据准备好了，select就会返回，用户调用read等函数，就会从内核态拷贝到用户进程。


### Reactor

主从Reactor, Reactor负责监听和分配事件，主线程中会有一个epoll事件，然后如果发生了可读事件，那么就会唤醒，获取到主Reactor得到的clientfd,得到的clientfd会将这个fd发送给subReactor，然后让subReactor监听可读可写，mainReactor只是分配工作。

rpc基本基于这种模型写的，
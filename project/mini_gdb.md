# min_gdb

这里主要是讨论gdb调试的原理

## 原理

### ptrace

基本上依赖于这个函数`ptrace`，可以切换到

- `long ptrace(request, pid_t pid, void *addr, void *data)`
  - request: 宏定义，比如说`PTRACE_TRACEME`, `PTRACE_PEEKDATA`等，表示一个动作
  - pid: 要调试的进程号
  - addr: 要写入的地址
  - data: 写入地址的话 data就是数据，读出地址的话，就会赋值给data。

### 中断原理

- 中断的本质还是修改代码
- 有一条汇编语言(断点指令) INT 3(interrupt 3)(对应的机器码是0xcc)，将其插入到代码中，当程序运行到这里的时候，就会发出`SIGNTRP`信号, 这时候父程序就可以对其进行捕获，然后父进程就可以使用`ptrace()`进行操纵相关的数据，在原来的代码上进行修改代码。插入`INT 3`，然后要将原来的信息进行保留，运行之后才会再放回原位，(程序一步一步的执行，执行到0xcc的时候就会进行中断，如果想执行后面的东西，那么就先恢复回来，然后再执行)
  - 程序执行的时候，PC寄存器上得到当前代码，如果说在这代码上打过断点了，那么就获得这个代码，然后解除断点，将原来的指令加入，然后运行这个代码

### 寻找C/C++函数和变量等，并且打断点

打断点的地方可以是地址，所以说你需要知道C变量中的变量的地址，所以就需要一定的调试信息 -> elf文件(编译和链接可执行文件)和Dwarf文件（调试信息文件

- 变量存放在在哪？
  - 可以在全局数据区，在栈内存上，寄存器上也有可能（立即数），具有相同名称的变量在不同的词法作用域中可能有不同的值，设置编译器可以直接将常数进行优化
  - 所以要全部捕捉他们呢。
- DIE中含有很多信息：
  - DW_TAG_subprogram: 用来描述函数（也称为子程序,main函数，或者其他函数不都是函数么，所以从中可以知道很多信息
  - DW_AT_name  : (...): main， 很显然，是这个名字，
  - DW_AT_low_pc： 函数的寄存器的入口   
  - DW_AT_location: 变量在给定时刻在内存中的位置 
  - .debug_line: 行号和机械码之间的映射

### 栈

系统调用的时候，自动会进行压栈出栈，系统调用栈大部分组成是：

```text
    High
        |   ...   |
        +---------+
     +24|  Arg 1  |
        +---------+
     +16|  Arg 2  |
        +---------+
     + 8| Return  |
        +---------+
EBP+--> |Saved EBP|
        +---------+
     - 8|  Var 1  |
        +---------+
ESP+--> |  Var 2  |
        +---------+
        |   ...   |
            Low
```

- 栈要保存很多变量，都是直接进行压栈。
- 还会保存`返回地址`:(从被调用函数结束后调用者继续执行的指令地址)
- 与栈相关的寄存器：
  - rsp寄存器：指向函数调用的栈顶
  - rbp寄存器：函数栈帧开始的位置
    - 可以得出 `返回地址 = 栈帧（也就是rbp寄存器） + 8`，因为栈是从高地址向低地址蔓延，所以这里是 + 8


### 断点位置

- 函数返回：如果说要在

## 名词解释

- DIE: 调试信息表项 （Debugging Information Entry），每个DIE有一个标签 ——> 包含它的类型，以及一组属性。各个DIE之间通过兄弟和孩子结点互相链接，属性值可以指向其他的DIE。





# tiny_rpc

哎，很多东西在面试官的面前说的话，非常急，就是可能条例不是很清晰，所以将我的话写在了下面


## 网络相关

### 为什么Tcp是三次握手，而不是其他次握手？

- 哎，元戎二面提了这个，我没有很好的回答出来
- 原因：
  - 阻止重复历史连接的初始化（主要原因）（清除历史记录）
  - 同步对方的初始序列号
  - 避免资源的浪费
- 四次握手当然可以解决这个问题，但是没有必要

### time_wait状态一般发生在哪一个地方？

- 客户端/服务端都可以出现，是先进行四次挥手的会触发time_wait状态，如果迟迟没有收到对方的发送的报文，就会处于time_wait状态，这时候这个端口是不能使用的，因为客户端的端口是改变的，但是服务端一般绑定的是同一个端口，导致这个端口就会不能使用，程序再启动就启动不老，端口显示已经占用

### 什么是SYN攻击？

- 当客户端只是发送SYN，但是并不没有

### OS kernel相关？

- OS会维护两个队列，Tcp半连接状态和Tcp全连接状态。
  - 如果说全连接状态非空，就会给accept()返回一个文件描述符

### `bind("0.0.0.0")`这样的地址，代表的是什么？

- 服务端才会bind()，代表的是监听所有的的地址，所有的ip地址都会监听。

## protobuf相关

### 为什么使用protobuf这个序列化工具的呢？

- 因为序列化非常简单，编码出来的大小比xml，json小很多
- 采用了varint编码，他编码出来的东西可以更小，
- 优点：
  - 因为编码出来的数据要小，那么他节约贷款
  - 序列化和反序列化出来快，程序运行就非常快

### protobuf中各个类的作用是什么？

- 要继承这些类，重写里面的 virtual函数，才能使用
- `google::protobuf::Message`：进行反序列化的信息和序列话的信息
- `google::protobuf::Service`: `CallMethod()`,执行对应的函数
- `google::protobuf::controller`：RpcController，相当于一个配置文件
- `google::protobuf::Closure`: 执行的回调函数, 好像并没有用上

### 客户端/服务端

- 因为`Everything is file`，网络的来的是accept()的来的文件描述符，所以说EventLoop·
- 服务器主要的是`TcpServer`这个类，当创建这个类的的时候，就会创建`mainReactor`和`subReactor`，创建的端口要会一直监听，注意：这里的当创建的时候，mainReactor，就会开始loop循环了，subReactor就已经开始loop循环了，`这里使用了信号量和互斥锁的性质去保护这个线程`
  - 因为在执行到构造函数的时候，就会开辟线程，要等到一些对象初始化完之后，你才能够使用开辟的线程去处理任务，这里使用了`信号量`的机制去控制这个线程的进行
- 在Linux中一切都是文件，`Everything is file`，因为最终会将数据放到`epoll`中进行处理，那么这里要处理函数怎么办？其实就是`epoll_event`,`epoll_event.data.ptr`是一个`void*`，将FdEvent绑定到这个上面，获取获取到`Fdevent`,获取其中的`函数`，然后加入到本地的pending任务中，然后最后执行就可以了。
  - 函数判断的时候其实跟位运算的差不多似的,（使用的是位掩码）所以这里实际上应该是`trigger_event.events & EPOLLIN`，如果说要取消，那么大致是`m_listen_events.events &= (~EPOLLIN);`，这样取反就可以了
- `TcpConnection`代表是的是客户端与服务端的一条连接，一般服务端是固定的，那么当一条客户端与服务端连接成功了，那么就有有一条`TcpConnection`的连接，注意：`TcpConnection`中，会有一个`EventLoop`对象，相当于一个绑定，`一个TcpConnection中随机得到一个EventLoop`，然后将处理事件加入到`EventLoop`中。
- 客户端发送的时候发送的直接是`AbstraceProtocol`这样的类，然后将其

## 面试的

### IO多路复用是什么？

- 以前处理请求的时候，客户端可以开一个进程，或者说开一个线程去处理他，但是这样也太浪费时间了，因为开辟进程和线程的时间消费是非常高的，（上下文切换啥的，两毫秒那样的时间复杂度），于是就产生了IO多路复用。使用一个进程来维护多个socket()，这样就可以在一个进程中处理很多的IO事件

### select/poll/epoll的相关考点

- select
  - fd集合是一个数组，每次使用都会将其从用户态拷贝到内核态，耗费时间
  - 数组需要便利，浪费时间
  - 文件描述符是1024,不够大
- poll
  - poll其实就是突破了文件描述符的最大限制,并且固定大小的集合换成了由链表实现的动态数组。但是还是受文件描述符的限制。
- epoll
  - 将用户关心的文件描述符事件存放在内核中，通过内存映射，在用户态进行访问，（重复拷贝是利用mmap这样的技术来实现避免拷贝
  - 将事件（回调函数）加入到就绪列表中，调用`epoll_wait`就可以检查是否有多于的fd,然后给用户就可以了
  - 工作模式：
    - 水平触发（默认）：当有刻度事件的时候，就会一直epoll_wait()等待数据的出现，直到内核缓冲区数据被read()完之后才能使用。
    - 边缘触发：当有可读事件触发的时候，就会从epoll_wait中只wait()一次，告诉有数据来

### 死锁的条件有哪些？

- 两个线程都在等待对方释放锁
- 互斥条件
- 持有并等待条件
- 不可剥夺条件
- 环路等待条件
- 乐观锁和悲观锁：本项目中使用的是悲观锁，乐观锁有点像无锁编程

### Reactor模式和Proactor模式有什么差别？

- 项目中使用的是多线程多Reactor模式，有一个主线程mainReactor，其他线程是多个Reactor线程，
- linux的socket()是不支持Proactor模式的，所以说都是基于Reactor模式
- 这里面还有堵塞IO/非堵塞IO，默认都是堵塞的，不是非堵塞的。使用`fcntl()`进行设置

### 工作模式

- LT模式：默认的工作模式，检测触发的时候，不会立刻处理事件，放到就绪列表中，下次使用，再通知
- ET模式：必须要处理，下次调用的时候，不会再次相应（只支持非堵塞模式），

## 项目疑问

### 主要实现的功能有什么？

- 实现Mutil-Reactor架构，底层采用了epoll实现了多路复用，
- 实现了protobuf编解码器的开发，实现了自定义协议
- 实现了一个异步的日志打印的工作。

### IO多路复用和线程池的池化思想有什么不同和特殊之处？为什么不能直接使用池化的思想去处理数据？

- 普通的线程池不能这样处理，因为客户端的请求可能会来很多这样的请求，比如说成百上千个，池化的思想虽然说里面有线程池，但是远远不够这些数字，所以说只能用IO多路复用，`IO多路复用一次性可以处理成百上千的任务，但是线程池可执行不了这些任务，会堵塞在那里`。

### Muti-Reactor的架构的优势是什么？为什么选用这个架构？

- 传统的线程模型都是堵塞的类型，也就是说，当一个线程去处理一个IO事件的时候，就会堵塞在这里，发生堵塞的话，就没有办法处理其他的事务了，那么多个任务来到这里时候，后面的任务可能就会一直在等待，没有更好的办法处理任务，
- 那么对于Reactor架构呢，他是非堵塞的，主线程是一个EvnetLoop循环，还有四个副线程，也就是subReactor，当有任务监听的时候，因为在Linux上一切揭文件，将文件转发到subReactor进行处理，所以说主线程是非堵塞的，异步的，然后subReactor处理之后，将结果发送给客户端
  - `客户端发送是同步的，因为要接受相关的消息`
  - `服务端的mainReactor是异步的，他就是主线程，因为他只是负责将文件描述符转发到subReactor上面，让subReactor处理，所以说服务端是异步的`
  - `subReactor底层采用的是一个epoll实现了一个多路IO复用，当有事件反应的时候，就会触发，然后进行处理`
  - `但是这里处理的时候并不是一个异步的模型，因为他需要处理相关的事件，所以这里是同步的，但是整体来说这里是异步的`。

### 日志的竞争状态是怎么做的？或者异步的是怎么做的？

- mainReactor和subReactor会将数据发送到一个共有的日志器里的buffer里面，因为这里设计到多个线程共同使用到同一个状态，这里使用了一下自旋锁，因为我觉得这个时间不是那么么的满（与std::mutex 锁住要快一些）之后，会将一个定时任务推送到EventLoop循环中进行执行，这时候，每隔一段事件去判断判断将这个logger里面的数据输送到AsyncLogger的loop循环中，然后将日志打印到本地，方便调试。这里相当于一个`生产者-消费者的模型`。

### 为什么要设计自定义协议？为什么采用protobuf这样的序列化的东西？可以不序列化后传输到网络上，然后直接读取么？

- 不行的，因为 网络序和字节序是不一样的，网络序是大端，然后字节序是小端，你如果直接传输，会相反，所以要进行序列化，然后变成网络序，然后再变成字节序
- 网络上传输的都是字节，但是本地的是得到的结果是字符串，那么你就需要序列化成字节，然后再在网络上进行传播，
- Tcp设置协议的时候不会说有粘包这一说，因为字节流，Tcp只是保证了你会传送到这个端口上,(保证了按照顺序到达到对方的端口)但是并不保证了数据是怎么字节的划分，这时候就需要设计一个自定义协议，提供给客户端和服务端进行发送和拆分

### 协议的大致样子是什么呢？

- 开始符 - 整包长度 - MsigID长度 - MsgID - 方法名长度 - 方法名 - 错误码 - 错误信息长度 - 错误信息 - protobuf序列化数据 - 校验码 - 结束符
- 设计校验码的问题是：`Tcp只是保证了数据按照顺序到达你这个服务端，但是并没有保证数据可能出现泄密篡改，所以说还要进行安全校验`。

### 协议中为什么会设置一个`msg_id`这样的序列号？

- 防止串包：当客户端的一个端口号有多个请求的时候，因为你要进行远程过程调用，那么你就要出现串包（请求是1 2 发送，可能收到的时候是 2 1 这样收到，就会发生串包），所以这个时候就要设计一个msg_id，保证这个序列化号，而且要唯一

### 协议是如何进行可扩展的？

- 协议是设计成虚函数的样子进行扩展的，最上面的是函数是虚函数，虚函数相当于提供了一个接口，然后下面是实现的函数，`注意：这里的有一个专门的智能指针进行转换`，与之类比的是协议，因为IPv4或者说是IPV6这样的协议，可以提供一个顶层的统一接口，然后使用的时候，分别处理就行了，但是IPV6有了，但其实用的不是很多，所以说这里就没有用到虚函数，直接就是IPv4这样的类去包装以下相关函数。

### 这个项目中什么是非堵塞的，什么是堵塞的？

- 项目中，有一个主线程，就是mainReactor，他是非堵塞的，当有相关请求的时候，主线程不会阻塞，会将处理这个请求给subReactor，交给subReactor，有点像线程池的概念，在subReactor里面执行，但是subReacor请求任务时候，这时候并不是异步的，而不是同步的，因为他要进行函数处理。
- 这里申请的文件描述符是需要需要申请非堵塞：因为客户端当有多个connect连接的时候，如果有一连接都断开的客户端，那么服务端accept就会堵塞，这时候就会一直杜塞到这里，所以说要设置成非堵塞。
- 函数处理的时候，统一使用的是`std::function<void()>`，虽然说`std::function<void()>`有性能损耗，但是他使用起来十分方面
- 设置非堵塞的地方：
  - `setsockopt(m_listenfd, SOL_SOCKET, SO_REUSEPORT, &valid, sizeof(valid));`：减少非堵塞的情况。`处于time_wait`状态的不能用，这里要这样处理。

### 如果优雅的进行关闭

- Tcp连接建立的时候，其实是建立两个相互不干扰的流的，输入和输出流，如果说直接调用`close(fd)`，那么就会同时关闭这两条流。
- 因为虽然输出输出完了，但是可能她还没接收完，所以说你就需要使用`shutdown()`关闭一方的流，否则数据的传输可能出现问题。

### Rpc如何对请求进行处理

- 项目中是实现了一个主从Reactor架构，mainReactor和subReactor都是一个EventLoop循环，当有连接来的时候，mainReactor会负责其连接，这时候就会得到对应的socket文件描述符，主线程只负责连接，连接之后将得到的文件描述符放到其中一个subReactor里面，Reactor里面是epoll进行事件处理，然后处理相关事件，这时候，得到的socket就会进行IO读写，将其放入到缓冲区里面，在这之前，就有对应的read()函数放到了EventLoop里面，然后进行解析，就会进行相关的rpc解析，解析完之后，就会将其返回到对方的客户端。这就是完成了一次rpc调用。

### 怎么提高并发量优化，怎么提高线程池的设计优化，任务过多的时候，线程池如何设计优化？

- 我觉得在业务设计差不多的时候，最有效的方法其实就是升级硬件
- subReactor可以根据性能，我设置的是根据cpu的线程数进行计算的，当然这个可以直接设置到配置文件中，根据需求进行更改。
- 也可以加入一些复杂均衡的设计，我这里用了一个非常小的复杂均衡，就是每次从iothreadgroup取出来一个iothread，都会计算一下这个任务的多少，取出来最小的那个，这里并没有使用互斥锁或者自旋锁等手段保证这个获取是准确的数值，因为我觉得这样有点小题大做了，仅仅是估算了一下这个任务的的多少。否则可能因为加锁而导致效率下降

### 非堵塞的read，如何判断相关的错误码呢？

- 如果是堵塞的read，那么他直接返回 -1 就好了，但是非堵塞的状态，他这样就完成不是很好，那么就需要返回一个错误码，errno = EAGIN，当出现这个错误码的时候，就说明已经读完了。

# tiny_rpc

## 八股面经

- IO多路复用是什么？
  - 以前处理请求的时候，客户端可以开一个进程，或者说开一个线程去处理他，但是这样也太浪费时间了，因为开辟进程和线程的时间消费是非常高的，（上下文切换啥的，两毫秒那样的时间复杂度），于是就产生了IO多路复用。使用一个进程来维护多个socket()，这样就可以在一个进程中处理很多的IO事件
- select/poll/epoll的相关考点
  - select
    - fd集合是一个数组，每次使用都会将其从用户态拷贝到内核态，耗费时间
    - 数组需要便利，浪费时间
    - 文件描述符是1024,不够大
  - poll
    - poll其实就是突破了文件描述符的最大限制,并且固定大小的集合换成了由链表实现的动态数组。但是还是受文件描述符的限制。
  - epoll
    - 将用户关心的文件描述符事件存放在内核中，通过内存映射，在用户态进行访问，（重复拷贝是利用mmap这样的技术来实现避免拷贝
    - 将事件（回调函数）加入到就绪列表中，调用`epoll_wait`就可以检查是否有多于的fd,然后给用户就可以了
    - 工作模式：
      - 水平触发：当有刻度事件的时候，就会一直epoll_wait()等待数据的出现，直到内核缓冲区数据被read()完之后才能使用。
      - 边缘触发：当有可读事件触发的时候，就会从epoll_wait中只wait()一次，告诉有数据来


### 工作模式

- LT模式：默认的工作模式，检测触发的时候，不会立刻处理事件，放到就绪列表中，下次使用，再通知
- ET模式：必须要处理，下次调用的时候，不会再次相应（只支持非堵塞模式），

## 项目疑问

- IO多路复用于线程池的池化思想有什么共同和特殊之处？为什么不用池化的思想去处理数据
  - 普通的线程池不能这样处理，因为客户端的请求可能会来很多这样的请求，比如说成百上千个，池化的思想虽然说里面有线程池，但是远远不够这些数字，所以说只能用IO多路复用
- 
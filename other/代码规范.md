# 代码规范

## 头文件的使用方法

1. 函数的原型声明应该遵守最小依赖性，很多不需要的头文件可以直接删去
2. 头文件的之间的依赖关系应该自给自足，为什么第一个.cc文件的第一个头文件应该完全包含这个文件？
3. 编写防卫式声明的时候应该写全，我一般是从include下的目录开始写的。同时，gcc可以进行优化，如果有第二个相同的头文件，甚至可能不会去读它
4. 头文件包含的时候，我一般是从特殊到一般写入，并且如果出现依赖性的编译，那么应该再次包含它，比如B include A, C include B, 这时候C 如果使用了A，我觉得应该在此include A，这样如果B中文件发生改变，那么C还是能用的。（就是将代码依赖搞到最小化）。
5. 编写的时候，代码顺序我喜欢是`C库 C++ 库 依赖第三方项目的库 自身的库`

## 初始化

如果不是外部引用声明，还是将声明和定义放在一起比较好，`这里又一个点，就是全局变量初始化是UB的，虽然规定是在main()前发生，但是并没有保证在哪一个特定的时间初始化，所以说UB的`
静态变量的构造函数，析构函数和初始化顺序在C++中是不确定的，会随着构建还是改变，所以还是禁用了么

所以全局变量必须是原生数据类型（POD），及那些int，char，以及POD类型的指针，数组和结构体。

```c++
// a.cpp
#include <string>
std：：string a = "test";

// b.cpp
#include <iostream>

extern std::string a;
std::string b = a;

int main() {
        std::cout<<b<<std::endl;
}
```

如果编译的时候，`g++ b.cpp a.cpp -o main`这样编译的时候就会发生错误。

如果非要使用，那么我觉得应该用一个函数来保证其构造函数发生在函数中。

```c++
std::shared_ptr<int> a { nullptr };

std::shared_ptr<int> get_ptr() {
    if (!a) {
        a = std::make_unique<int>(2);
    }
    return a;
}
```

禁止了这个，但是放在全局变量上指针还是可以的，有点像单例模式。

## 构造函数

- 构造函数中不要调用其他函数，防止出现错误，
- 对单个参数的构造函数使用 c++ 关键字 explict，想一想，只有单个参数的时候才有可能出现异议，就是一般来说，一种才有隐式转换。

## 注释

- 使用`//`代替`/**/`。有利于你使用`diff`进行查看不同，能够直接看到当前函数是否被注释掉了。
- 每一个类中都要有一个 头文件，描述这个类中是什么功能。
- 函数声明处注释函数功能，定义处描述函数实现
- `永远不要用自然语言翻译代码来作为注释，要假设写代码的人C++水平比你高，即使他不知道你的用意`

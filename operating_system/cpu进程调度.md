# cpu进程调度

- `T(周转) = T(完成) - T(到达)` 越快表示完成的时间越少
- `T(相应) = T(首次运行) - T(到达时间)` 越快表示开始的时间越快

cpu肯定要将上面的两个时间都变短。

## 先进先出(FIFO), 最短任务优先(SJF), 最短时间算法(STCF)

- 都是串行化的，完成一个再完成另一个，FIFO是根据时间顺序来
- SJF可以根据某一道算法题可知，将时间短的放前面的时间也快很多
- STCF加入了抢占式算法，如果来了更短的，那么更短的来运行

## 轮询

- cpu将工作单位划分为中断时间单位的整数倍，然后在当前时间片上进行作业，那么响应时间就会大大缩减，但是周转时间会变大，但是又能怎么样的（
- 并且配合IO,因为IO的时候可以通过中断来切换到另一个程序里面，

## 调度算法（多级反馈队列）

MLFQ: 多级反馈队列
- 有多个独立的队列，每一个队列都有一个不同的优先级

1. 如果A的优先级 > B的优先级，那么优先执行A的优先级
2. 如果A的优先级 = B的优先级，那么轮流执行A与B
3. 当一个工作进入系统中的时候，会放在最高的优先级上面（最上层队列）
4. 一旦工作用完了其在某一层中间的时间配额（无论中间主动放弃多少次），都会降低其优先级（移入低一级的队列中）
5. 经过一段时间S，就将系统中所有的工作重新加入到最高的优先级队列中去。

## 多核cpu进行调度

多核cpu可以快速进行多核心运算，但是最重要的是: 要保证缓存一致性，每一个cpu都有自己的缓存，缓存

### 如何保证cpu缓存一致性

基于总线的系统上，可以总线嗅探（？，每一个缓存都可以监听，如果cpu对这些缓存中的数据进行更新，那么会作废本地缓存中的数据或者更新新值，

### 缓存亲和度

当然，一个程序在一个核心上运行比较长时间之后，有缓存亲和度的概念，（有缓存了呗，调度的时候尽量调度到同一个核心上。
# 性能优化

`cpu计算只能减轻计算瓶颈，不能减轻内存瓶颈。`，因为内存读写实在是太慢太慢了，对于加速那些只有访存的代码，并行的性能优化其实是不大的。  

## 数据访问的大致速度

1次浮点读写约等于8次浮点加法
这里待补充的图片

L1/L2/L3 read 和 Main RAM read 的时间指的是 读取一个缓存行（64字节）所花费的时间

right 和 wrong 指的是 分支预测是否成功

核心数目越多，cpu计算机能力越强，从来来不及从内存中读写数据，越容易遇到内存瓶颈。

缓存分三级，一级缓存还分数据缓存和指令缓存。指令一般是只读的。缓存起来比较好。  

## 缓存工作机制

缓存的数据结构

```c++
struct CacheEntry {
    bool valid, dirty;
    uint64_t address;
    char data[64];
};
```

### 缓存的读

cpu读取一个地址，如果发现了这个地址，那么就直接返回，如果没有，就等待读取数据，然后创建一个缓存。
`x84_64`架构中每一个条目存储64字节的数据，称之为缓存行(cacheline)。  
虽然每次读取的时候是4字节，但是缓存每次都会读取64字节的内容，这样就会缓存命中。
`数据对其对其到内存行`

### 缓存的写

写入地址的时候，
如果在缓存中找到，那么就修改，如果找不到，就创建，并且标记为脏。
缓存快溢出的话，向主存发送请求，写入成功，就会安全移除这个条目。
多级缓存中，一级缓存失败的话，就会丢给二级缓存。

缓存行决定了数据的粒度，
> 访问内存的量的时候，和访问的内存量无关，和访问的每个字节的缓存行有关。-> 空间局域性

## 例子

设置结构体的时候就会出现内存对齐的现象

```c++  
// 访问全部的 a 需要很多cacheline
struct MyClass {
    double a, b, c, d, e, f, g, h;
};

// 访问全部的 a 只需要 一个cacheline 64字节
struct Myclass {
    double a[8];
    double b[8];
    double c[8];
};
```

根据内存排布，如果访问的话，下面的访问多个x是更好的，（因为一个cacheline是64字节）

### 内存布局

AOS(array of struct) 单个对象紧密排布（2的幂才高效，如果内存有空缺，c++编译器会进行补充） 
SOA(struct of array) 数据分离进行排布（不需要）

## 如何加快速度

1. 数据变小，使得可以存在缓存中，这样速度就有可能超过内存的读取速度。因为数据都存储在缓存中了

# 性能优化

`cpu计算只能减轻计算瓶颈，不能减轻内存瓶颈。`，因为内存读写实在是太慢太慢了，对于加速那些只有访存的代码，并行的性能优化其实是不大的。  

## 数据访问的大致速度

1次浮点读写约等于8次浮点加法
这里待补充的图片

L1/L2/L3 read 和 Main RAM read 的时间指的是 读取一个缓存行（64字节）所花费的时间

right 和 wrong 指的是 分支预测是否成功

核心数目越多，cpu计算机能力越强，从来来不及从内存中读写数据，越容易遇到内存瓶颈。

缓存分三级，一级缓存还分数据缓存和指令缓存。指令一般是只读的。缓存起来比较好。  

## 缓存工作机制

缓存的数据结构

```c++
struct CacheEntry {
    bool valid, dirty;
    uint64_t address;
    char data[64];
};
```

### 缓存的读

cpu读取一个地址，如果发现了这个地址，那么就直接返回，如果没有，就等待读取数据，然后创建一个缓存。
`x84_64`架构中每一个条目存储64字节的数据，称之为缓存行(cacheline)。  
虽然每次读取的时候是4字节，但是缓存每次都会读取64字节的内容，这样就会缓存命中。
`数据对其对其到内存行`

### 缓存的写

写入地址的时候，
如果在缓存中找到，那么就修改，如果找不到，就创建，并且标记为脏。
缓存快溢出的话，向主存发送请求，写入成功，就会安全移除这个条目。
多级缓存中，一级缓存失败的话，就会丢给二级缓存。

缓存行决定了数据的粒度，
> 访问内存的量的时候，和访问的内存量无关，和访问的每个字节的缓存行有关。-> 空间局域性

## 例子

设置结构体的时候就会出现内存对齐的现象

```c++  
// AOS
// 访问全部的 a 需要很多cacheline
struct MyClass {
    double a, b, c, d, e, f, g, h;
};

// SOA
// 访问全部的 a 只需要 一个cacheline 64字节
struct MyClass {
    double a[8];
    double b[8];
    double c[8];
};

// AOSOA
// 内部是SOA,但是外部仍是是一个AOS
struct MyClass {
    float x[1024];
    float y[1024];
    float z[1024];
};

std::vector<MyClass> mc(n / 1024);
```

根据内存排布，如果访问的话，下面的访问多个x是更好的，（因为一个cacheline是64字节）

### 内存布局

AOS(array of struct): 单个对象紧密排布（2的幂才高效，如果内存有空缺，c++编译器会进行补充）  
SOA(struct of array): 数据分离进行排布（不需要）(因为访问同一个x的时候只会读取一个cacheline)
AOSSOA: 没一个SOA数组的大小是一个页（4kb, 4 * 1024）这样才会最高效，但是需要两次指标索引，麻烦。

SOA总是比AOS好一点，如果面向数据（过程编程）将数据拆分出来，那么SOA确实是比较强的

## 预取(prefetch)

根据时间局部性和空间局部性，cpu会预先取来周围的一些数据，`这种只有在顺序读取，或者跨步读取`的时候才会生效，感觉有点像分支预测，但是如果是随机读取，那么就会浪费时间。

## 读取要比写入快

读取要比写入的快一些，
cpu ----4 字节 ---- cache ---- 64 字节 ---- 主存

每次最少用的就是一个缓存行的大小（64字节），如果你要修改小于64字节的东西，那么你就要读取64个字节才能写入其中1个字节。

## malloc的分配

第一次malloc申请的时候用的时候为什么会慢呢？

```c++
    int* arr = (int*)malloc(n * sizeof(int));
    
    for (int i = 0; i < n; i++) {
        arr[i] = 1;
    }

    // 这一步就要快？
    for (int i = 1; i < n; i++) {
        arr[i] = 1;
    }
```

### 结论

分配是按照页面（4kb）来管理的。  
malloc并不会直接分配一块内存，而是标记为不可用，而是标记为不可用，如果要写入的话，那么就会触发缺页中断（page fault），如果找到了这个是曾经malloc的地址，那么就会开辟内存，如果访问错误，就是段错误。`分配内存的懒惰性`

```c++
std::vector<int>, new int[n]{ }; 会初始化数组为0
malloc(n * sizeof(n)); new int[n]; 不会初始化数组为0
```

```c++
template <typename T>
struct NoInit {
    T value;

    // do not something ....
    NoInit() {

    }
};

int main() {
    std::vector<NoInit<int>> arr(n); // 这样使用的时候才会初始化
}
```

#### 论文

SPGrid()
tbbmalloc

## 多维数组

多维数组都是扁平化的，多维数组实际上只是压扁的一维数组

### 二维动态数组 ！= 二级指针

```c++
int main() {
    int n = 10;
    int m = 10;
    int** arr = (int**)malloc(n * sizeof(int*));
    for (int i = 0; i < m; i++) {
        arr[i] = (int*)malloc(m * sizeof(int));
    }
    // do something...

    for (int i = 0; i < m; i++) {
        free(arr[i]);
    }
    free(arr);
}
```

以上是错误的，因为这样分类的内存都是分散的，而且访问都需要解开两层指针，非常低效率。

```c++
// 正确方法, 通过 arr[i * m + j] 这样的 访问第 i 行， 第 j 列的元素。
int* arr = malloc(n * m * sizeof(int));
```

## 如何加快速度

1. 数据变小，使得可以存在缓存中，这样速度就有可能超过内存的读取速度。因为数据都存储在缓存中了
2. 缓存行对其，叶对齐（64字节对其，4kb对其）

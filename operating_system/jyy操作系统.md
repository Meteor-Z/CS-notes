# jyy操作系统

希望能坚持下去

## 多处理器编程

操作系统可以作为状态机的并发操作，比如文件可以让其他软件进行共享，这算是并发，同时操作系统对这些进行管理，软件的打印输出，如果是多线程，那么打印的时候就有可能不一样。

linux上`top`上的cpu占用，超过了100%,大致就是使用了了多核处理器。

并且这些并发的线程都是共享同一块内存的。

多线程情况下每一个线程都是独立的栈么，但是总共的栈默认都是8mb吧？，然后可以调的

### 原子性

`哪怕是一条汇编指令，也没有原子性`，因为在多核处理器上面，这个是不存在的
在下面的代码上，不管是`cnt++`还是`++cnt`,答案都不是`2*N`,cpu在处理的时候不会这样进行
只有加入锁的情况下，才能保证其原子性。

所以说，要保证线程安全，建议都要加锁捏~
```c++
#include <thread>
#include <iostream>
#include <mutex>

const int N = 100000;
int cnt = 0;
std::mutex mutx;
void task()
{
    for (int i = 0; i < N; i ++)  
    {
        // mutx.lock();
        cnt++;
        // mutx.unlock();
    }
}

int main()
{
    std::thread t1(task);
    std::thread t2(task);
    t1.join();
    t2.join();
    std::cout << cnt << std::endl;
    return 0;
}
```

操，为什么开了`-O2` 他居然是对的？ 循环的时候读数据的时候有可能是错误的。
因为直接循环展开，然后弄成常数了，为啥要循环啊，好傻逼，

你写代码+编译器的优化+程序的执行，这些都可能影响到你写的代码，所以说，还是相信自己，写一个完美的代码吧！

## 多处理器的可见性 ？

现代处理器的实现：

你以为的：
    一个cpu执行一条指令到达下一状态
实际上的：
    电路将指令继续划分。

IPC？
一个时钟周期基本上执行一条指令，但是很多的情况下一条指令需要1以上的时钟周期。
这里面很杂，csapp上有很多讲解，其中还有流水线优化什么的。好难，这不是我能了解的范围。

`Do not communicate by sharing memory; instead, share memory by communicating.`


## 并发基础

如果并发出现了问题，可以试着退回来，就是变成顺序执行。
让并发的程序不在并发。要有锁来将这个

两个线程A B,A线程不知道B将锁拿走了，然后就Aj

失败的尝试。

这样不断重复的要锁的结果是对的，还是错误的？
```c++
int locked = UNLOCK;

void critical_section() 
{
retry:
    if (locked != UNLOCK) // 如果一个东西不是开锁状态，那么就一直请求，然后拿到锁 
    {
        goto retry;
    }
    locked = LOCK;
    
    // 执行代码

    locked = UNLOCK;
}

```

并发操作不能保证这样的程序按照其正常的逻辑执行。因为两个程序有可能同时检测到相关的信息，然后同时进入

假设：内存的读/写可以保证顺序读写 （也就是 load 和 store）

读：读的时候相当于睁眼一下子睁眼，然后直接闭眼。之后的信息不能感受到了
写：相当于对一个地方贴纸条，但是贴完之后拿下下来，就有可能被别人覆盖。

`Petson算法`

好怪啊！
A和B想要争厕所
如果想要争厕所，那么需要举起自己的旗子。
然后A里面有B的标签，B有A的标签。然后盲目的往上面贴。
`如果对面举着其，然后门上的名字是他的`，等待。
否则，就可以进入厕所。
出厕所之后，要放下自己的旗子。（不顾门上的标签）

如果证明？：妈的，直接跟他爆了，有限状态机，直接暴力枚举所有的情况，然后看有无范例。

### 原子指令

硬件和编译器共同打造提供一些`不可打断，不可优化`的指令

### 互斥问题


## 可执行文件

在linux上，所有的东西都是文件。


# 数据库系统实现

## 磁盘

数据库中主导的IO开销大部分都是磁盘读写花费的时间，（远大于操纵主存中的数据花费的时间），
所以有先前的机械硬盘，之后就出来了固态硬盘。

### IO查询

注意到：CPU和磁盘的工作是分开的，这两个是不同的设备，所以当一个进程在IO查询的时候，就可以直接让这个线程休眠，然后去做其他的事情，如果说这IO完成了，那么硬件就发送一个中断，可以让CPU继续执行这个进程。（如果没有中断，就会不断的轮询这个硬盘（你做完了么，你做完了么））导致CPU性能下降。

### 加快磁盘访问

1. 多个磁盘：相当于多个双通道内存，可以加快速度
2. 磁盘镜像：多个磁盘，如果有多个读写内容，可以分配给这些硬盘一起读写。
3. 磁盘调度和电梯算法：将磁盘左右寻道时间比做成电梯，相当于电梯在路途中间接人一样，这样就可以提高速度了。

### 磁盘故障

#### 奇偶校验和

#### RAID阵列

这个很简单，多快硬盘组在一起，但是在用户看起来，是一块硬盘，同时，在内部在（速度有安全）之间进行抉择，但是对于单块速度，要更加安全，速度更快。

## 索引结构

索引是一种数据结构，它以一个或者多个字段的数值为输出并能够`快速地`找出具有该值的记录。

如果一个记录是排好序的，那么就可以在记录上建立一个索引，`块中只存记录的键以及只想记录本身的指针。`，（从索引中找到这个指向数据本身的地址，然后根据指针来找到记录（一次IO就可以做到）

一个数据块上可以存上不同的数据（多个数据），那么就有区分了。

### 稠密索引

为每一个块上的不同数据都建议一个索引，比如说一个数据块上有2个数据，就建立两个索引

### 稀疏索引

一个块上可能可能有两个数据，但是只是为一个块建立一个索引，两个数据共用一个索引，如果查到了话，就在数据中再次查到，`注意：很显然，这个需要一定的排序`

数据是混乱的存储的，但是索引可以按照一定的顺序进行存储，所以相当于一个排序，（可以二分查找了）然后在索引中进行二分，然后查到相关数据

### 多级索引

想一想，索引在排序的时候就可以直接变成顺序的的，那么就可以再次基础上建立稀疏索引，然后进一步简化。（因为索引也要占用一定的地方）
妈的，有点像线段树，但是为什么会被B+ 树取代了呢？

### B树结构

aka 史上最强数据结构

将上面的索引结构和数据块想象成一颗树，在这颗树上，索引就是子节点，然后每一个子节点中就会有指针，指向数据块。

#### 优点

1. 自动保存数据大小相适应的索引层次
2. 对使用的存储块结构，使每一个块的充满结构在半满和全满之间

#### B树的结构

注意到，所有的数值都是在最下面的节点里面（就是在子节点里面），其中叶子节点仅仅是为了辅助查找的信息，信息全部都存在最底层的子节点里面。
重复的和不重复的能挂在一起么？就是将重复的挂在一起，形成一个串。？

#### B树的效率

想一想二分，可以想象，查找，删除等时间效率基本上都是O($logn$)
